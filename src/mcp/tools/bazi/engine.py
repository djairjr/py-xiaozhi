"""Bazi calculation core engine."""

from datetime import datetime
from typing import Any, Dict, List, Optional

import pendulum
from lunar_python import Lunar, Solar

from .models import (
    ChineseCalendar,
    EarthBranch,
    EightChar,
    HeavenStem,
    LunarTime,
    SixtyCycle,
    SolarTime,
)
from .professional_data import (
    GAN,
    GAN_WUXING,
    GAN_YINYANG,
    SHENG_XIAO,
    ZHI,
    ZHI_CANG_GAN,
    ZHI_WUXING,
    ZHI_YINYANG,
)


class BaziEngine:
    """Bazi calculation engine."""

    # Dynamically construct Tiangan mapping - based on data from professional_data.py
    HEAVEN_STEMS = {}
    for gan in GAN:
        HEAVEN_STEMS[gan] = HeavenStem(
            name=gan, element=GAN_WUXING[gan], yin_yang=GAN_YINYANG[gan]
        )

    # Dynamically construct earthly branch mapping - based on data from professional_data.py
    EARTH_BRANCHES = {}
    for i, zhi in enumerate(ZHI):
        # Obtain the Tibetan stems of the Earthly Branches
        cang_gan = ZHI_CANG_GAN.get(zhi, {})
        cang_gan_list = list(cang_gan.keys())

        # Construct the EarthBranch object
        EARTH_BRANCHES[zhi] = EarthBranch(
            name=zhi,
            element=ZHI_WUXING[zhi],
            yin_yang=ZHI_YINYANG[zhi],
            zodiac=SHENG_XIAO[i],
            hide_heaven_main=cang_gan_list[0] if len(cang_gan_list) > 0 else None,
            hide_heaven_middle=cang_gan_list[1] if len(cang_gan_list) > 1 else None,
            hide_heaven_residual=cang_gan_list[2] if len(cang_gan_list) > 2 else None,
        )

    def __init__(self):
        """initialization."""

    def parse_solar_time(self, iso_date: str) -> SolarTime:
        """Parse Gregorian time strings (supports multiple formats) - uses pendulum optimization to enhance time zone handling."""
        try:
            # Use pendulum to parse time, support more formats
            dt = pendulum.parse(iso_date)

            # Intelligent time zone handling
            if dt.timezone_name == "UTC":
                # If pendulum is parsed as UTC (indicating that the original input has no time zone), it will be treated as Beijing time.
                dt = dt.replace(tzinfo=pendulum.timezone("Asia/Shanghai"))
            elif dt.timezone_name is None:
                # If there is no time zone information, set it to Beijing time
                dt = dt.replace(tzinfo=pendulum.timezone("Asia/Shanghai"))
            elif dt.timezone_name != "Asia/Shanghai":
                # Convert to Beijing time
                dt = dt.in_timezone("Asia/Shanghai")

            return SolarTime(
                year=dt.year,
                month=dt.month,
                day=dt.day,
                hour=dt.hour,
                minute=dt.minute,
                second=dt.second,
            )
        except Exception:
            # If pendulum parsing fails, try other formats
            formats = [
                "%Y-%m-%dT%H:%M:%S+08:00",
                "%Y-%m-%dT%H:%M:%S+0800",
                "%Y-%m-%dT%H:%M:%S.%f+08:00",
                "%Y-%m-%dT%H:%M:%S.%f",
                "%Y-%m-%dT%H:%M:%S",
                "%Y-%m-%dT%H:%M+08:00",
                "%Y-%m-%dT%H:%M",
                "%Y-%m-%d %H:%M:%S",
                "%Y-%m-%d %H:%M",
                "%Y-%m-%d",
                "%Y/%m/%d %H:%M:%S",
                "%Y/%m/%d %H:%M",
                "%Y/%m/%d",
                "%Y year %m month %d day %H hour %M minute %S second",
                "%Y year %m month %d day %H hour %M minute",
                "%Y year %m month %d day",
            ]

            dt = None
            for fmt in formats:
                try:
                    dt = datetime.strptime(iso_date, fmt)
                    break
                except ValueError:
                    continue

            if dt is None:
                raise ValueError(
                    f"Unable to parse time format: {iso_date}, supported formats include ISO8601, Chinese format, etc."
                )

            return SolarTime(
                year=dt.year,
                month=dt.month,
                day=dt.day,
                hour=dt.hour,
                minute=dt.minute,
                second=dt.second,
            )

    def solar_to_lunar(self, solar_time: SolarTime) -> LunarTime:
        """Convert Gregorian calendar to lunar calendar - Enhanced leap month processing."""
        try:
            # Real Gregorian-Lunar calendar conversion using lunar-python
            solar = Solar.fromYmdHms(
                solar_time.year,
                solar_time.month,
                solar_time.day,
                solar_time.hour,
                solar_time.minute,
                solar_time.second,
            )
            lunar = solar.getLunar()

            # Determine whether it is a leap month
            is_leap = lunar.isLeap() if hasattr(lunar, "isLeap") else False

            # If lunar-python does not have an isLeap method, use other methods to determine
            if not hasattr(lunar, "isLeap"):
                # Judge by month string (if it contains the word "leap")"字）
                month_str = lunar.getMonthInChinese()
                is_leap = "leap" in month_str

            return LunarTime(
                year=lunar.getYear(),
                month=lunar.getMonth(),
                day=lunar.getDay(),
                hour=lunar.getHour(),
                minute=lunar.getMinute(),
                second=lunar.getSecond(),
                is_leap=is_leap,
            )
        except Exception as e:
            raise ValueError(f"Failed to convert Gregorian calendar to lunar calendar: {e}")

    def lunar_to_solar(self, lunar_time: LunarTime) -> SolarTime:
        """Convert lunar calendar to Gregorian calendar - enhance leap month processing."""
        try:
            # Handling leap months
            if lunar_time.is_leap:
                # If it is a leap month, use a special method to create a lunar calendar object
                lunar = Lunar.fromYmdHms(
                    lunar_time.year,
                    -lunar_time.month,  # Leap months are represented by negative numbers
                    lunar_time.day,
                    lunar_time.hour,
                    lunar_time.minute,
                    lunar_time.second,
                )
            else:
                # Ordinary month
                lunar = Lunar.fromYmdHms(
                    lunar_time.year,
                    lunar_time.month,
                    lunar_time.day,
                    lunar_time.hour,
                    lunar_time.minute,
                    lunar_time.second,
                )

            solar = lunar.getSolar()

            return SolarTime(
                year=solar.getYear(),
                month=solar.getMonth(),
                day=solar.getDay(),
                hour=solar.getHour(),
                minute=solar.getMinute(),
                second=solar.getSecond(),
            )
        except Exception as e:
            raise ValueError(f"Failed to convert lunar calendar to Gregorian calendar: {e}")

    def build_eight_char(self, solar_time: SolarTime) -> EightChar:
        """Construct the horoscope."""
        try:
            # Use lunar-python to calculate horoscopes
            solar = Solar.fromYmdHms(
                solar_time.year,
                solar_time.month,
                solar_time.day,
                solar_time.hour,
                solar_time.minute,
                solar_time.second,
            )
            lunar = solar.getLunar()
            bazi = lunar.getEightChar()

            # Get year column
            year_gan = bazi.getYearGan()
            year_zhi = bazi.getYearZhi()
            year_cycle = self._create_sixty_cycle(year_gan, year_zhi)

            # Get moon column
            month_gan = bazi.getMonthGan()
            month_zhi = bazi.getMonthZhi()
            month_cycle = self._create_sixty_cycle(month_gan, month_zhi)

            # Get daily bar
            day_gan = bazi.getDayGan()
            day_zhi = bazi.getDayZhi()
            day_cycle = self._create_sixty_cycle(day_gan, day_zhi)

            # Get time bar
            time_gan = bazi.getTimeGan()
            time_zhi = bazi.getTimeZhi()
            time_cycle = self._create_sixty_cycle(time_gan, time_zhi)

            return EightChar(
                year=year_cycle, month=month_cycle, day=day_cycle, hour=time_cycle
            )
        except Exception as e:
            raise ValueError(f"Failed to build Bazi: {e}")

    def _create_sixty_cycle(self, gan_name: str, zhi_name: str) -> SixtyCycle:
        """Create a Sixty Years object."""
        heaven_stem = self.HEAVEN_STEMS[gan_name]
        earth_branch = self.EARTH_BRANCHES[zhi_name]

        # Calculate the sound
        try:
            # Use voice data
            sound = self._get_nayin(gan_name, zhi_name)
        except Exception as e:
            # Log specific errors but do not affect overall functionality
            print(f"Nayin calculation failed: {gan_name}{zhi_name} - {e}")
            sound = "unknown"

        # Computing ten days and voids - simplified implementation
        ten = self._get_ten(gan_name, zhi_name)
        extra_branches = self._get_kong_wang(gan_name, zhi_name)

        return SixtyCycle(
            heaven_stem=heaven_stem,
            earth_branch=earth_branch,
            sound=sound,
            ten=ten,
            extra_earth_branches=extra_branches,
        )

    def _get_nayin(self, gan: str, zhi: str) -> str:
        """Get the sound."""
        from .professional_data import get_nayin

        return get_nayin(gan, zhi)

    def _get_ten(self, gan: str, zhi: str) -> str:
        """Get Xun - using Sixty Years Xun Kong algorithm"""
        from .professional_data import GAN, ZHI

        try:
            # Use the standard sixty-year calculation method
            gan_idx = GAN.index(gan)
            zhi_idx = ZHI.index(zhi)

            # Calculate the serial number in sixty years (starting from 1)
            jiazi_number = (gan_idx * 6 + zhi_idx * 5) % 60
            if jiazi_number == 0:
                jiazi_number = 60

            # The first ten days of the sixties
            xun_starts = ["Jiazi", "Jiaxu", "Jiashen", "Jiawu", "Jiachen", "Jiayin"]

            # Determine the ten days (every ten days is one ten day)
            xun_index = (jiazi_number - 1) // 10

            if 0 <= xun_index < len(xun_starts):
                return xun_starts[xun_index]
            else:
                # Use a more accurate calculation method
                return self._calculate_xun_by_position(jiazi_number)
        except (ValueError, IndexError) as e:
            print(f"Ten days calculation failed: {gan}{zhi} - {e}")
            return "Jiazi"

    def _get_kong_wang(self, gan: str, zhi: str) -> List[str]:
        """Get void - using traditional void algorithm"""
        from .professional_data import GAN, ZHI

        try:
            gan_idx = GAN.index(gan)
            zhi_idx = ZHI.index(zhi)

            # Calculate the serial number in sixty years
            jiazi_number = (gan_idx * 6 + zhi_idx * 5) % 60
            if jiazi_number == 0:
                jiazi_number = 60

            # Determine the location
            xun_index = (jiazi_number - 1) // 10

            # The sixty-year-old void earthly branch
            kong_wang_table = [
                ["Xu", "Hai"],  # Jiazi Xun
                ["state", "unitary"],  # Jiaxu
                ["noon", "not yet"],  # Jiashenxun
                ["Chen", "Si"],  # Jiawu
                ["Yin", "Mao"],  # Jiachenxun
                ["son", "ugly"],  # Jiayinxun
            ]

            if 0 <= xun_index < len(kong_wang_table):
                return kong_wang_table[xun_index]
            else:
                # Alternate calculation method
                return self._calculate_kong_wang_by_position(jiazi_number)
        except (ValueError, IndexError) as e:
            print(f"Air death calculation failed: {gan}{zhi} - {e}")
            return ["Xu", "Hai"]  # Default returns to Jiazixun empty death

    def format_solar_time(self, solar_time: SolarTime) -> str:
        """Format Gregorian calendar time."""
        return f"{solar_time.year} year {solar_time.month} month {solar_time.day} day {solar_time.hour} hour {solar_time.minute} minute {solar_time.second} second"

    def format_lunar_time(self, lunar_time: LunarTime) -> str:
        """Format lunar time."""
        return f"Lunar calendar {lunar_time.year} year {lunar_time.month} month {lunar_time.day} day {lunar_time.hour} hour {lunar_time.minute} minute {lunar_time.second} second"

    def get_chinese_calendar(
        self, solar_time: Optional[SolarTime] = None
    ) -> ChineseCalendar:
        """Get traditional Chinese calendar information - using lunar-python"""
        if solar_time is None:
            # Use today
            now = pendulum.now("Asia/Shanghai")
            solar_time = SolarTime(
                now.year, now.month, now.day, now.hour, now.minute, now.second
            )

        try:
            solar = Solar.fromYmdHms(
                solar_time.year,
                solar_time.month,
                solar_time.day,
                solar_time.hour,
                solar_time.minute,
                solar_time.second,
            )
            lunar = solar.getLunar()

            # Get details
            bazi = lunar.getEightChar()

            return ChineseCalendar(
                solar_date=self.format_solar_time(solar_time),
                lunar_date=f"{lunar.getYearInChinese()} year {lunar.getMonthInChinese()} month {lunar.getDayInChinese()}",
                gan_zhi=f"{bazi.getYear()} {bazi.getMonth()} {bazi.getDay()}",
                zodiac=lunar.getYearShengXiao(),
                na_yin=lunar.getDayNaYin(),
                lunar_festival=(
                    ", ".join(lunar.getFestivals()) if lunar.getFestivals() else None
                ),
                solar_festival=(
                    ", ".join(solar.getFestivals()) if solar.getFestivals() else None
                ),
                solar_term=lunar.getJieQi() or "none",
                twenty_eight_star=lunar.getXiu(),
                pengzu_taboo=lunar.getPengZuGan() + " " + lunar.getPengZuZhi(),
                joy_direction=lunar.getPositionXi(),
                yang_direction=lunar.getPositionYangGui(),
                yin_direction=lunar.getPositionYinGui(),
                mascot_direction=lunar.getPositionFu(),
                wealth_direction=lunar.getPositionCai(),
                clash=f"Chong {lunar.getDayChongDesc()}",
                suitable=", ".join(lunar.getDayYi()[:5]),  # Take the first 5
                avoid=", ".join(lunar.getDayJi()[:5]),  # Take the first 5
            )
        except Exception as e:
            raise ValueError(f"Failed to obtain almanac information: {e}")

    def _calculate_xun_by_position(self, jiazi_number: int) -> str:
        """Ten days are calculated based on the sixty-year serial number."""
        # Using GANZHI_60 from professional_data.py
        # first ten days of every ten days
        xun_starts = ["Jiazi", "Jiaxu", "Jiashen", "Jiawu", "Jiachen", "Jiayin"]

        xun_index = (jiazi_number - 1) // 10
        if 0 <= xun_index < len(xun_starts):
            return xun_starts[xun_index]
        else:
            return "Jiazi"

    def _calculate_kong_wang_by_position(self, jiazi_number: int) -> List[str]:
        """Calculate air losses based on the sixty-year serial number."""
        # The sixty-year-old void earthly branch
        kong_wang_table = [
            ["Xu", "Hai"],  # Jiazi Xun
            ["state", "unitary"],  # Jiaxu
            ["noon", "not yet"],  # Jiashenxun
            ["Chen", "Si"],  # Jiawu
            ["Yin", "Mao"],  # Jiachenxun
            ["son", "ugly"],  # Jiayinxun
        ]

        xun_index = (jiazi_number - 1) // 10
        if 0 <= xun_index < len(kong_wang_table):
            return kong_wang_table[xun_index]
        else:
            return ["Xu", "Hai"]

    def get_detailed_lunar_info(self, solar_time: SolarTime) -> Dict[str, Any]:
        """Get detailed lunar calendar information."""
        try:
            solar = Solar.fromYmdHms(
                solar_time.year,
                solar_time.month,
                solar_time.day,
                solar_time.hour,
                solar_time.minute,
                solar_time.second,
            )
            lunar = solar.getLunar()

            # Get solar term information
            current_jieqi = lunar.getJieQi()
            next_jieqi = lunar.getNextJieQi()
            prev_jieqi = lunar.getPrevJieQi()

            # Get more traditional information
            return {
                "current_jieqi": current_jieqi,
                "next_jieqi": next_jieqi.toString() if next_jieqi else None,
                "prev_jieqi": prev_jieqi.toString() if prev_jieqi else None,
                "lunar_festivals": lunar.getFestivals(),
                "solar_festivals": solar.getFestivals(),
                "twenty_eight_star": lunar.getXiu(),
                "day_position": {
                    "xi": lunar.getPositionXi(),
                    "yang_gui": lunar.getPositionYangGui(),
                    "yin_gui": lunar.getPositionYinGui(),
                    "fu": lunar.getPositionFu(),
                    "cai": lunar.getPositionCai(),
                },
                "pengzu_taboo": {
                    "gan": lunar.getPengZuGan(),
                    "zhi": lunar.getPengZuZhi(),
                },
                "day_suitable": lunar.getDayYi(),
                "day_avoid": lunar.getDayJi(),
                "day_clash": lunar.getDayChongDesc(),
            }
        except Exception as e:
            print(f"Failed to obtain detailed lunar calendar information: {e}")
            return {}


# Global engine instance
_bazi_engine = None


def get_bazi_engine() -> BaziEngine:
    """Get the Bazi engine single instance."""
    global _bazi_engine
    if _bazi_engine is None:
        _bazi_engine = BaziEngine()
    return _bazi_engine
